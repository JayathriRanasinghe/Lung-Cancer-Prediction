# -*- coding: utf-8 -*-
"""Lung-Cancer-Level-prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XuU828q3EmcEz_KPWCGkhnPKpmUIJ3md
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os
import math
import shutil # to move files from one folder to the another
import glob

import seaborn as sns
import plotly.express as px

import warnings
warnings.filterwarnings("ignore")

# For model creation and performance evaluation
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.metrics import roc_curve, roc_auc_score

!wget https://www.dropbox.com/s/ok34wbkwdtnpcg0/cancer%20patient%20data%20sets.csv?dl=0

# Load dataset
data = pd.read_csv("/content/cancer patient data sets.csv?dl=0")

# check for missing values
print(data.isnull().sum())
# drop rows with missing values
data.dropna(inplace=True)

data.drop_duplicates(keep='first')

# Check weather distribution
plt.figure(dpi=100)
sns.countplot(data=data, x="Level") #Precipitation (PRECIPM). Precipitation is the total amount of rain that falls within a specific observation period
plt.xlabel("Count")
plt.ylabel("Number of patients")
plt.show()

# Label rain precentage into Raining (1) and Not rainging (0)
# data['Level'] = data['Level'].apply(lambda x: 1 if x >= 50 else 0)

data['Level'] = data['Level'].apply(lambda x: 2 if x == "High" else (1 if x == "Medium" else 0))

# Calculate the correlation matrix
corr_matrix = data.corr()
# Plot heatmap
plt.figure(figsize=(12, 8), dpi=100)
sns.heatmap(corr_matrix, center=0, cmap='Blues', annot=True)
plt.show()

# Drop the target variable
X = data.drop(['Level','Patient Id'], axis=1)
# Set the target variable as the label
y = data['Level']

# Split the data into training and testing sets (20% testing and 80% training)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.10, random_state=42)

# Create an object of the logistic regression model
logreg_model = LogisticRegression()

# Fit the model to the training data
logreg_model.fit(X_train, y_train)

from sklearn.model_selection import GridSearchCV

# Define the parameter grid
param_grid = {
    'C': [0.1, 1, 10, 100],
    'penalty': ['l1', 'l2'],
    'solver': ['liblinear', 'saga'],
    'max_iter': [100, 200, 300]
}

# Create a logistic regression model
logistic_model = LogisticRegression()

# Perform grid search
grid_search = GridSearchCV(logistic_model, param_grid, scoring='f1', cv=5)
grid_search.fit(X_train, y_train)

# Retrieve the best hyperparameters
best_params = grid_search.best_params_

# Calculate F1 scores
initial_model = LogisticRegression()  # Instantiate a new logistic regression model
initial_model.fit(X_train, y_train)  # Fit the model on the training data
initial_model_f1 = f1_score(y_test, initial_model.predict(X_test),average = 'macro')

best_model_f1 = f1_score(y_test, grid_search.best_estimator_.predict(X_test), average = 'macro')

print("Initial Model F1 Score:", initial_model_f1)
print("Best Model F1 Score:", best_model_f1)

# Choose the best model
best_logistic_model = grid_search.best_estimator_
print(best_logistic_model)

# Predict the labels of the test set
y_pred = grid_search.predict(X_test)

# Create the confusion matrix
confusion_mat = confusion_matrix(y_test, y_pred)

# Compute the accuracy of the model
accuracy = accuracy_score(y_test, y_pred)
# Compute the precision of the model
precision = precision_score(y_test, y_pred, average = 'macro')
# Compute the recall of the model
recall = recall_score(y_test, y_pred, average = 'macro')
# Compute the F1 score of the model
f1 = f1_score(y_test, y_pred, average = 'macro')
print("Accuracy = ", accuracy)
print("Precision = ", precision)
print("Recall = ", recall)
print("F1_score = ", f1)

pip install dash

import dash
from dash import dcc, html
from dash.dependencies import Input, Output, State

# Create the Dash app
app = dash.Dash(__name__)
# Define the layout of the dashboard
app.layout = html.Div(
children=[
html.H1('Lung Cancer Level Prediction',style={'backgroundColor':'white'}),
# Layout for exploratory data analysis: correlation between two selected features
html.Div([
html.H3('Exploratory Data Analysis'),
html.Label('Feature 1 (X-axis)'),
dcc.Dropdown(
id='x_feature',
options=[{'label': col, 'value': col} for col in data.columns],
value=data.columns[0]
)
], style={'width': '30%', 'display': 'inline-block'}),
html.Div([
html.Label('Feature 2 (Y-axis)'),
dcc.Dropdown(
id='y_feature',
options=[{'label': col, 'value': col} for col in data.columns],
value=data.columns[1]
)
], style={'width': '30%', 'display': 'inline-block'}),
dcc.Graph(id='correlation_plot'),
# Layout for wine quality prediction based on input feature values
html.H3("Wine Quality Prediction"),
html.Div([
    html.Table([
        html.Tr([
            html.Td(html.Label("Age")),
            html.Td(dcc.Input(id='age', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Gender")),
            html.Td(dcc.Input(id='gender', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Air Pollution")),
            html.Td(dcc.Input(id='air_pollution', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Alcohol Use")),
            html.Td(dcc.Input(id='alcohol_use', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Dust Allergy")),
            html.Td(dcc.Input(id='dust_allergy', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("OccuPational Hazards")),
            html.Td(dcc.Input(id='occupational_hazards', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Genetic Risk")),
            html.Td(dcc.Input(id='genetic_risk', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("chronic Lung Disease")),
            html.Td(dcc.Input(id='chronic_lung_disease', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Balanced Diet")),
            html.Td(dcc.Input(id='balanced_diet', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Obesity")),
            html.Td(dcc.Input(id='obesity', type='number', required=True))
        ]),
         html.Tr([
            html.Td(html.Label("Smoking")),
            html.Td(dcc.Input(id='smoking', type='number', required=True))
        ]),
         html.Tr([
            html.Td(html.Label("Passive Smoker")),
            html.Td(dcc.Input(id='passive_smoker', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Chest Pain")),
            html.Td(dcc.Input(id='chest_pain', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Coughing of Blood")),
            html.Td(dcc.Input(id='coughing_of_blood', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Fatigue")),
            html.Td(dcc.Input(id='fatigue', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Weight Loss")),
            html.Td(dcc.Input(id='weight_loss', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Shortness of Breath")),
            html.Td(dcc.Input(id='shortness_of_breath', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Wheezing")),
            html.Td(dcc.Input(id='wheezing', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Swallowing Difficulty")),
            html.Td(dcc.Input(id='swallowing_difficulty', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Clubbing of Finger Nails")),
            html.Td(dcc.Input(id='clubbing_of_finger_nails', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Frequent Cold")),
            html.Td(dcc.Input(id='frequent_cold', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Dry Cough")),
            html.Td(dcc.Input(id='dry_cough', type='number', required=True))
        ]),
        html.Tr([
            html.Td(html.Label("Snoring")),
            html.Td(dcc.Input(id='snoring', type='number', required=True))
        ])
    ])
])
,
html.Div([
html.Button('Predict', id='predict-button', n_clicks=0),
]),
html.Div([
html.H4("Predicted Quality"),
html.Div(id='prediction-output')
])
])

print(data.isnull().sum())

# Define the callback to update the correlation plot
@app.callback(
  dash.dependencies.Output('correlation_plot', 'figure'),
  [dash.dependencies.Input('x_feature', 'value'),
  dash.dependencies.Input('y_feature', 'value')]
)
def update_correlation_plot(x_feature, y_feature):
  fig = px.scatter(data, x=x_feature, y=y_feature, color='quality')
  fig.update_layout(title=f"Correlation between {x_feature} and {y_feature}")
  return fig
# Define the callback function to predict wine quality
@app.callback(
  Output(component_id='prediction-output', component_property='children'),
  [Input('predict-button', 'n_clicks')],
  [State('age', 'value'),
  State('gender', 'value'),
  State('air_pollution', 'value'),
  State('alcohol_use', 'value'),
  State('dust_allergy', 'value'),
  State('occupational_hazards', 'value'),
  State('genetic_risk', 'value'),
  State('chronic_lung_disease', 'value'),
  State('balanced_diet', 'value'),
  State('obesity', 'value'),
  State('smoking', 'value'),
  State('passive_smoker', 'value'),
  State('chest_pain', 'value'),
  State('coughing_of_blood', 'value'),
  State('fatigue', 'value'),
  State('weight_loss', 'value'),
  State('shortness_of_breath', 'value'),
  State('wheezing', 'value'),
  State('swallowing_difficulty', 'value'),
  State('clubbing_of_finger_nails', 'value'),
  State('frequent_cold', 'value'),
  State('dry_cough', 'value'),
  State('snoring', 'value')]
)
def predict_quality(n_clicks, age, gender, air_pollution,alcohol_use,
    dust_allergy, occupational_hazards, genetic_risk, chronic_lung_disease,
    balanced_diet, obesity, smoking, passive_smoker, chest_pain, 
    coughing_of_blood, fatigue, weight_loss, shortness_of_breath, wheezing,
    swallowing_difficulty, clubbing_of_finger_nails, frequent_cold, dry_cough,
    snoring):
  # Create input features array for prediction
  input_features = np.array([age, gender, air_pollution,alcohol_use,
    dust_allergy, occupational_hazards, genetic_risk, chronic_lung_disease,
    balanced_diet, obesity, smoking, passive_smoker, chest_pain, 
    coughing_of_blood, fatigue, weight_loss, shortness_of_breath, wheezing,
    swallowing_difficulty, clubbing_of_finger_nails, frequent_cold, dry_cough,
    snoring]).reshape(1, -1)
  # Predict the wine quality (0 = bad, 1 = good)
  prediction = logreg_model.predict(input_features)[0]
  # Return the prediction
  if prediction == 2:
    return 'High'
  elif prediction == 1:
    return 'Medium'
  else:
    return 'Low'

if __name__ == '__main__':
  app.run_server(debug=False)